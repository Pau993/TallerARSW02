Analisis

1. Analice el código para entender cómo hace uso de hilos para crear un comportamiento autónomo de las N serpientes.
- Para cada serpiente, cada hilo opera de forma independiente, tomando sus propias decisiones de movimiento con su propia velocidad,
responde y detecta las colisiones propias y se mueve sin coordinación con otras serpientes, también interactuan con el tablero notificando los cambios,
en esto se permite ver el paralelismo por las multiples serpientes moviendose simultaneamente, también son independientes por la operacion individual,
y el acceso compartido al tablero con la concurrencia.

2. De acuerdo con lo anterior, y con la lógica del juego, identifique y escriba claramente (archivo RESPUESTAS.txt):
- Posibles condiciones de carrera:
El acceso no sincronizado a Board.gameboard cuando multiples serpientes verifican la misma celda.
Modificación concurrente de los arrays compartidos (food[], barriers[], jump_pads[], turbo_boosts[]).
Actualización no atómica de la posición de la comida cuando una serpiente la come.
- Uso inadecuado de colecciones, considerando su manejo concurrente (para esto, aumente la velocidad del juego y ejecútelo varias veces hasta que se genere un error).
LinkedList snakeBody en Snake.java no es thread-safe.
Arrays estaticos en Board (food[], barriers[], etc.) sin sincronización adecuada.
Acceso concurrente a las colecciones sin mecanismos de protección.
- Uso innecesario de esperas activas.
// En SnakeApp.java
```
while (true) {int x = 0;
    for (int i = 0; i != MAX_THREADS; i++) {
        if (snakes[i].isSnakeEnd() == true) {
            x++;
        }
    }
    if (x == MAX_THREADS) {
        break;
  }
}
```
Es una espera activa (busy-waiting): constantemente verifica el estado de las serpientes en un ciclo infinito sin pausas, ya que se debe ejecutar el ciclo continuamente Verificar cada serpiente repetidamente y No libera el tiempo de procesamiento para otros hilos

