Análisis

1. Análisis del Código
   
   Se analizó el código para comprender cómo hace uso de hilos para crear un comportamiento autónomo de las N serpientes.
   - Para cada serpiente, cada hilo opera de forma independiente, tomando sus propias decisiones de movimiento con su propia velocidad.
   - Cada serpiente detecta sus propias colisiones y se mueve sin coordinación con otras serpientes.
   - Las serpientes interactúan con el tablero notificando los cambios.
   - Se observa el paralelismo debido a múltiples serpientes moviéndose simultáneamente.
   - Existe independencia por la operación individual de cada serpiente.
   - El acceso compartido al tablero introduce problemas de concurrencia.

2. Identificación de Problemas de Concurrencia

   a. Posibles condiciones de carrera:
   - Acceso no sincronizado a `Board.gameboard` cuando múltiples serpientes verifican la misma celda.
   - Modificación concurrente de los arrays compartidos (`food[]`, `barriers[]`, `jump_pads[]`, `turbo_boosts[]`).
   - Actualización no atómica de la posición de la comida cuando una serpiente la consume.

   b. Uso inadecuado de colecciones y manejo concurrente:
   - `LinkedList snakeBody` en `Snake.java` no es thread-safe.
   - Arrays estáticos en `Board` (`food[]`, `barriers[]`, etc.) sin sincronización adecuada.
   - Acceso concurrente a las colecciones sin mecanismos de protección.

   c. Uso innecesario de esperas activas:
   
   En `SnakeApp.java`, el siguiente fragmento de código representa una espera activa (busy-waiting):
   
   ```java
   while (true) {
       int x = 0;
       for (int i = 0; i != MAX_THREADS; i++) {
           if (snakes[i].isSnakeEnd() == true) {
               x++;
           }
       }
       if (x == MAX_THREADS) {
           break;
       }
   }
   ```
   
   Problemas:
   - El ciclo verifica constantemente el estado de las serpientes sin pausas.
   - No libera el tiempo de procesamiento para otros hilos.
   - Se recomienda el uso de mecanismos de sincronización adecuados, como `wait()` y `notifyAll()` para evitar la espera activa.
